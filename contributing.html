---
layout: page
title: 參與開發(英文)
---

  <p>Everyone is welcome to contribute to Swift.
Contributing doesn’t just mean submitting pull requests—there
are many different ways for you to get involved,
including answering questions on the mailing lists,
reporting or triaging bugs, and participating in the Swift evolution process.</p>

<p>No matter how you want to get involved,
we ask that you first learn what’s expected
of anyone who participates in the project
by reading the <a href="/community">Community Guidelines</a>.
If you’re contributing code, you should also know how to build and run
Swift from the repository,
as described in <a href="/source-code">Source Code</a>.</p>

<h2 id="answering-questions">Answering Questions</h2>

<p>One of the most important and immediate ways you can support the community
is to answer questions on the
<a href="/community/#mailing-lists">mailing lists</a>.
Whether you’re helping a newcomer understand a language feature
or troubleshooting an edge case with a seasoned developer,
your knowledge and experience of Swift
can go a long way to help others.</p>

<h2 id="reporting-bugs">Reporting Bugs</h2>

<p>Reporting bugs is a great way for anyone to help improve Swift. The open source Swift project uses Jira for tracking bugs. Our Jira instance is located at <a href="https://bugs.swift.org">bugs.swift.org</a>.</p>

<div class="info">
  <p>If a bug can be reproduced only within an Xcode project or a playground,
or if the bug is associated with an Apple NDA,
please file a report to Apple’s <a href="https://bugreport.apple.com">bug reporter</a> instead.</p>
</div>

<p>When filing a new Swift bug, please include the following:</p>

<ul>
  <li>
    <p><strong>A concise description of the problem.</strong>
If the issue is a crash, include a stack trace. Otherwise, describe the behavior you were expecting to see, along with the behavior you actually observed.</p>
  </li>
  <li>
    <p><strong>A reproducible test case.</strong>
If the test case is small (for example, less than 20 lines of code) paste it directly into the issue’s description field. Otherwise, upload it as an attachment to the Jira issue.</p>
  </li>
  <li>
    <p><strong>A description of the environment that reproduces the problem.</strong>
Include the Swift build number, as well as information about your target OS and platform.</p>
  </li>
</ul>

<p>Because Swift is under very active development, we receive a lot of bug reports. Before filing a new issue, take a moment to browse our <a href="https://bugs.swift.org">existing issues</a> to make sure you’re not filing a duplicate.</p>

<div class="warning">
  <p>Before filing an issue requesting a new language feature, see <a href="#participating-in-the-swift-evolution-process">Participating in the Swift Evolution Process</a>.</p>
</div>

<h2 id="triaging-bugs">Triaging Bugs</h2>

<p>Reporting bugs is an important part of improving software.
Nearly as important is triaging those bugs
to ensure that they are reproducible, small, and unique.</p>

<p>There are a number of things you can do to help triage bugs
in the <a href="https://bugs.swift.org">bug tracker</a>.</p>

<ul>
  <li>
    <p><strong>Reproduce bugs</strong>.
For a bug to be actionable,
it needs to be reproducible.
If you can’t reproduce the bug,
try to figure out why.
Get in touch with the submitter if you need more information.</p>
  </li>
  <li>
    <p><strong>Reduce bugs</strong>.
Once a bug can be reproduced,
reduce it to the smallest amount of code possible.
Reasoning about a sample that reproduces a bug in just a few lines of Swift code
is easier than reasoning about a longer sample.</p>
  </li>
  <li>
    <p><strong>Eliminate duplicate bugs</strong>.
If two bug reports refer to the same underlying problem,
mark the newer one as a duplicate of the older one.
Doing so allows others to work more effectively.</p>
  </li>
</ul>

<h2 id="contributing-code">Contributing Code</h2>

<h3 id="incremental-development">Incremental Development</h3>

<p>The Swift project uses <em>small, incremental changes</em> as its preferred development model.  Sometimes these changes are small bug fixes. Other times, these changes are small steps along the path to reaching larger stated goals.  In contrast, long-term development branches can leave the community without a voice during development. Some additional problems with long-term branches include:</p>

<ul>
  <li>Resolving merge conflicts can take a lot of time if branch development and mainline development occur in the same pieces of code.</li>
  <li>People in the community tend to ignore work on branches.</li>
  <li>Very large changes are difficult to code review.</li>
  <li>Branches are not routinely tested by the continuous integration infrastructure.</li>
</ul>

<p>To address these problems, Swift uses an incremental development style.  Small changes are preferred whenever possible.  We require contributors to follow this practice when making large or otherwise invasive changes. Some tips follow:</p>

<ul>
  <li>
    <p>Large or invasive changes usually have secondary changes that must be made before the large change (for example, API cleanup or addition). Commit these changes before the major change, independently of that work.</p>
  </li>
  <li>
    <p>If possible, decompose the remaining interrelated work into unrelated sets of changes. Next, define the first increment and get consensus on the development goal of the change.</p>
  </li>
  <li>
    <p>Make each change in the set either stand alone (for example, to fix a bug) or part of a planned series of changes that work toward the development goal. Explaining these relationships to the community can be helpful.</p>
  </li>
</ul>

<p>If you are interested in making a large change and feel unsure about its overall effect, please make sure to first discuss the change and reach a consensus through the <a href="/community/#swift-development">developer mailing list</a>. Then ask about the best way to go about making the change.</p>

<h3 id="commit-messages">Commit Messages</h3>

<p>Although we don’t enforce a strict format for commit messages, we prefer that you follow the guidelines below, which are common among open source projects.  Following these guidelines helps with the review process, searching commit logs, and email formatting. At a high level, the contents of the commit message should be convey the rationale of the change, without delving into much detail. For example, “bits were not set right” leaves the reviewer wondering about which bits and why they weren’t “right”. In contrast, “Correctly compute ‘is dependent type’ bits in ‘Type’” conveys almost all there is to the change.</p>

<p>Below are some guidelines about the format of the commit message itself:</p>

<ul>
  <li>Separate the commit message into a single-line <em>title</em> and a separate <em>body</em> that describes the change.</li>
  <li>Make the title concise to be easily read within a commit log and to fit in the subject line of a commit email.</li>
  <li>In changes that are restricted to a specific part of the code, include a [tag] at the start of the line in square brackets—for example, “[stdlib] …” or “[SILGen] …”. This tag helps email filters and searches for post-commit reviews.</li>
  <li>When there is a body, separate it from the title by an empty line.</li>
  <li>Make body concise, while including the complete reasoning. Unless required to understand the change, additional code examples or other details should be left to bug comments or the mailing list.</li>
  <li>If the commit fixes a bug in the bug tracking system, include the bug number in the message.</li>
  <li>For text formatting and spelling, follow the same rules as documentation and in-code comments—for example, the use of capitalization and periods.</li>
  <li>If the commit is a bug fix on top of another recently committed change, or a revert or reapply of a patch, include the Git revision number of the prior related commit, e.g. “Revert abcdef because it caused bug#”.</li>
</ul>

<p>For minor violations of these guidelines, the community normally favors reminding the contributor of this policy over reverting. Minor corrections and omissions can be handled by sending a reply to the commits mailing list.</p>

<h3 id="attribution-of-changes">Attribution of Changes</h3>

<p>When contributors submit a change to a Swift subproject, after that change is approved, other developers with commit access may commit it for the author. When doing so, it is important to retain correct attribution of the contribution. Generally speaking, Git handles attribution automatically.</p>

<p>We do not want the source code to be littered with random attributions like “this code written by J. Random Hacker”, which is noisy and distracting. Do not add contributor names to the source code or documentation.</p>

<p>In addition, don’t commit changes authored by others unless they have submitted the change to the project or you have been authorized to submit on their behalf—for example, you work together and your company authorized you to contribute the changes. The author should first either submit the change through a pull request to the relevant project, email the development list, or add a bug tracker item. If someone sends you a change privately, encourage them to submit it to the appropriate list first.</p>

<h3 id="code-templates">Code Templates</h3>

<p>As mentioned in the <a href="/community" title="Swift.org community guidelines">Community Guidelines</a>, the license and copyright protections for Swift.org code are called out at the top of every source code file.  On the rare occasion you contribute a change that includes a new source file, ensure that the header is filled out appropriately.</p>

<p>For Swift source files the code header should look this:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code><span class="c1">// subfolder/Filename.swift - Very brief description</span>
<span class="c1">//</span>
<span class="c1">// This source file is part of the Swift.org open source project</span>
<span class="c1">//</span>
<span class="c1">// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors</span>
<span class="c1">// Licensed under Apache License v2.0 with Runtime Library Exception</span>
<span class="c1">//</span>
<span class="c1">// See http://swift.org/LICENSE.txt for license information</span>
<span class="c1">// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors</span>
<span class="c1">//</span>
<span class="c1">// -----------------------------------------------------------------------------</span>
<span class="c1">///</span>
<span class="c1">/// This file contains stuff that I am describing here in the header and will</span>
<span class="c1">/// be sure to keep up to date.</span>
<span class="c1">///</span>
<span class="c1">// -----------------------------------------------------------------------------</span>
</code></pre>
</div>

<p>For C or C++ source or header files, the code header should look this:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code><span class="c1">//===-- subfolder/Filename.h - Very brief description -----------*- C++ -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
///
/// \file
/// This file contains stuff that I am describing here in the header and will
/// be sure to keep up to date.
///
//===----------------------------------------------------------------------===//
</span></code></pre>
</div>

<p>The divider lines should be exactly 80 characters wide to aid in adherence to the code style guidelines.  The bottom section contains an optional description intended for generated documentation (these lines begin with <code class="highlighter-rouge">///</code> rather than <code class="highlighter-rouge">//</code>).  If there is no description, this area can be skipped.</p>

<h3 id="code-review">Code Review</h3>

<p>The Swift project relies heavily on code review to improve software quality:</p>

<ul>
  <li>All significant changes, by all developers, must be reviewed before they are committed to the repository.  Smaller changes (or changes where the developer owns the component) can be reviewed after being committed.</li>
  <li>Code reviews are conducted on GitHub (through comments on pull requests or commits) and are reflected on the relevant project’s commit mailing list.</li>
  <li>The developer responsible for a code change is also responsible for making all necessary review-related changes.</li>
</ul>

<p>Code review can be an iterative process, which continues until the change is ready to be committed. After a change is sent out for review it needs an explicit approval before it’s submitted. Do not assume silent approval or request active objections to the patch by setting a deadline.</p>

<p>Sometimes code reviews will take longer than you would hope for, especially for larger features. Here are some accepted ways to speed up review times for your patches:</p>

<ul>
  <li>
<strong>Review other people’s changes.</strong> If you help out, everybody will be more willing to do the same for you.  Goodwill is our currency.</li>
  <li>
<strong>Split your change into multiple smaller changes.</strong> The smaller your change, the higher the probability that somebody will take a quick look at it.</li>
  <li>
<strong>Ping the change.</strong> If it is urgent, provide reasons why it is important to get this change landed and ping it every couple of days. If it is not urgent, the common courtesy ping rate is one week. Remember that you’re asking for valuable time from other professional developers.</li>
</ul>

<p>Note that anyone is welcome to review and give feedback on a change, but only people with commit access to the repository can approve it.</p>

<h3 id="testing">Testing</h3>

<p>Developers are required to create test cases for any bugs fixed and any new features added, and to contribute them along with the changes.</p>

<ul>
  <li>All feature and regression test cases are added to the appropriate test directory—for example, the <code class="highlighter-rouge">swift/test</code> directory.</li>
  <li>Write test cases at the abstraction level nearest to the actual feature. For example, if it’s a Swift language feature, write it in Swift; if it’s a SIL optimization, write it in SIL.</li>
  <li>Reduce test cases as much as possible, especially for regressions. It’s unacceptable to place an entire failing program into <code class="highlighter-rouge">swift/test</code> because this slows down testing for all developers. Please keep them short.</li>
</ul>

<h3 id="quality">Quality</h3>

<p>People depend on Swift to create their production software.  This means that a bug in Swift could cause bugs in thousands, even millions of developers’ products.  Because of this, the Swift project maintains a high bar for quality.  The minimum quality standards that any change must satisfy before being committed to the main development branch include:</p>

<ol>
  <li>Code must compile without errors or warnings on at least one platform.</li>
  <li>Bug fixes and new features must include a test case to pinpoint any future regressions, or include a justification for why a test case would be impractical.</li>
  <li>Code must pass the appropriate test suites—for example, the <code class="highlighter-rouge">swift/test</code> and <code class="highlighter-rouge">swift/validation-test</code> test suites in the Swift compiler.</li>
</ol>

<p>Additionally, the committer is responsible for addressing any problems found in the future that the change may cause. This responsibility means that you may need update your change in order to:</p>

<ul>
  <li>Ensure the code compiles cleanly on all primary platforms</li>
  <li>Fix any correctness regressions found in other test suites</li>
  <li>Fix any major performance regressions</li>
  <li>Fix any performance or correctness regressions in the downstream Swift tools</li>
  <li>Fix any performance or correctness regressions that result in customer code that uses Swift</li>
  <li>Address any bugs that appear in the bug tracker as a result from your change</li>
</ul>

<p>We prefer that these issues be handled before submission, but we understand that it isn’t possible to test all of this for every submission. Our continuous integration (CI) infrastructure normally finds these problems. We recommend watching the CI infrastructure throughout the next day to look for regressions. The CI infrastructure will directly email you if a group of commits that included yours caused a failure. You are expected to check those messages to see whether they are your fault and, if so, fix the breakage.</p>

<p>Commits that clearly violate these quality standards may be reverted, in particular when the change blocks other developers from making progress. The developer is welcome to recommit the change after the problem has been fixed.</p>

<h3 id="commit-access">Commit Access</h3>

<p>Commit access is granted to contributors with a track record of submitting high-quality changes. If you would like commit access, please send an email to <a href="mailto:code-owners@swift.org">the code owners list</a> with the GitHub user name that you want to use.</p>

<p>Once you’ve been granted commit access, you will be able to commit to all of the GitHub repositories that host Swift.org projects.  To verify that your commit access works, please make a test commit (for example, change a comment or add a blank line).  The following policies apply to users with commit access:</p>

<ul>
  <li>
    <p>You are granted commit-after-approval to all parts of Swift. To get approval, create a pull request. When the pull request is approved, you may merge it yourself.</p>
  </li>
  <li>
    <p>You may commit an obvious change without first getting approval. The community expects you to use good judgment. Examples are reverting obviously broken patches, correcting code comments, and other minor changes.</p>
  </li>
  <li>
    <p>You are allowed to commit changes without approval to the portions of Swift to which you have contributed or for which you have been assigned responsibility. Such commits must not break the build. This is a “trust but verify” policy, and commits of this nature are reviewed after being committed.</p>
  </li>
</ul>

<p>Multiple violations of these policies or a single egregious violation may cause commit access to be revoked.  Even with commit access, your changes are still subject to <a href="#code-review">code review</a>. Of course, you are also encouraged to review other peoples’ changes.</p>

<p><a name="evolution-process"></a></p>

<h2 id="participating-in-the-swift-evolution-process">Participating in the Swift Evolution Process</h2>

<p>Anyone with a good idea can help shape the future features and direction of the language.
To reach the best possible solution to a problem,
we discuss and iterate on ideas in a
<a href="/community/#swift-evolution">public forum</a>.
Once a proposal is refined and approved,
it becomes a release goal,
and is tracked as a feature of an upcoming version of Swift.</p>

<p>To support this process,
the <a href="https://github.com/apple/swift-evolution" title="Swift Evolution repository">Swift Evolution repository</a>
collects the goals for the upcoming major and minor releases
(as defined by the <a href="/community/#core-team">core team</a>)
as well as proposals for changes to Swift.
The <a href="https://github.com/apple/swift-evolution/blob/master/process.md" title="Swift Evolution process">Swift evolution process</a> document details how ideas are
proposed, discussed, reviewed, and eventually accepted into upcoming releases.</p>

<p>See the <a href="https://github.com/apple/swift-evolution/blob/master/schedule.md" title="Swift Evolution reviews">Swift evolution review schedule</a>
for current and upcoming proposal reviews.</p>

<hr>

<h2 id="llvm-and-swift">LLVM and Swift</h2>

<p>Swift is built on the <a href="http://llvm.org">LLVM Compiler Infrastructure</a>. Swift uses the LLVM Core for code generation and optimization (among other things), <a href="http://clang.llvm.org">Clang</a> for interoperability with C and Objective-C, and <a href="http://lldb.llvm.org">LLDB</a> for debugging and the REPL.</p>

<p>Swift maintains clones of the <a href="http://llvm.org/viewvc/llvm-project/llvm/">LLVM
Core</a>,
<a href="http://llvm.org/viewvc/llvm-project/cfe/">Clang</a>, and
<a href="http://llvm.org/viewvc/llvm-project/lldb/">LLDB</a> source repositories on
GitHub as <a href="https://github.com/apple/swift-llvm">swift-llvm</a>, <a href="https://github.com/apple/swift-clang">swift-clang</a>, and
<a href="https://github.com/apple/swift-lldb">swift-lldb</a>, respectively. These repositories track upstream LLVM development and contain
additional changes for Swift. The upstream LLVM repositories
are merged into the Swift-specific repositories frequently. Every
attempt is made to minimize the differences between upstream LLVM and
the Swift clones to only those changes specifically required for Swift.</p>

<h3 id="where-do-llvm-changes-go">Where Do LLVM Changes Go?</h3>

<p>Swift follows a policy of making a change in the most upstream
repository that is feasible. Contributions to Swift that involve
Swift’s versions of LLVM, Clang, or LLDB should go directly into the
upstream LLVM repositories unless they are specific to Swift. For
example, an improvement to LLDB’s data formatters for a Swift type
belongs in the Swift LLDB repository, whereas a bug fix to an LLVM
optimizer—even if it’s only been observed when operating on
Swift-generated LLVM IR—belongs in upstream LLVM.</p>

<p>Commits to an upstream LLVM repository are automatically merged
into the appropriate upstream branches in the corresponding Swift
repository (<code class="highlighter-rouge">upstream-with-swift</code> in the <a href="https://github.com/apple/swift-llvm">swift-llvm</a> and
<a href="https://github.com/apple/swift-clang">swift-clang</a> repositories, <code class="highlighter-rouge">upstream</code> in the
<a href="https://github.com/apple/swift-lldb">swift-lldb</a> repository). The workflows for the Swift compiler and
LLDB differ slightly:</p>

<ul>
  <li>
    <p>For the Swift compiler, the <code class="highlighter-rouge">upstream-with-swift</code> branches in
<a href="https://github.com/apple/swift-llvm">swift-llvm</a> and <a href="https://github.com/apple/swift-clang">swift-clang</a> contain the
latest upstream LLVM sources along with the Swift-specific changes and
additions. The <code class="highlighter-rouge">stable</code> branch (against which most Swift development
occurs) is periodically rebranched from <code class="highlighter-rouge">upstream-with-swift</code>. In the
interim, important commits should be cherry-picked from llvm.org
into <code class="highlighter-rouge">upstream-with-swift</code>, and then into <code class="highlighter-rouge">stable</code>.</p>
  </li>
  <li>
    <p>For LLDB, the <code class="highlighter-rouge">upstream</code> branch of <a href="https://github.com/apple/swift-lldb">swift-lldb</a> contains
a mirror of the <a href="http://llvm.org/viewvc/llvm-project/lldb/">upstream LLDB
repository</a>. The <code class="highlighter-rouge">master</code>
branch contains the Swift-specific code. The contents of <code class="highlighter-rouge">upstream</code>
are periodically merged into <code class="highlighter-rouge">master</code> at the same time that the Swift
compiler’s <code class="highlighter-rouge">stable</code> is rebranched. In the interim, important commits
should be cherry-picked from llvm.org into <code class="highlighter-rouge">upstream</code>, and then
into <code class="highlighter-rouge">master</code>.</p>
  </li>
</ul>

<h3 id="swift-and-llvm-developer-policies">Swift and LLVM Developer Policies</h3>
<p>Contributions to Swift’s LLVM or Clang clones are governed by the <a href="http://llvm.org/docs/DeveloperPolicy.html">LLVM
Developer Policy</a> and
should follow the appropriate
<a href="http://llvm.org/docs/DeveloperPolicy.html#copyright-license-and-patents">licensing</a>
and <a href="http://llvm.org/docs/CodingStandards.html">coding standards</a>.
Issues with LLVM code are tracked using the <a href="https://llvm.org/bugs" title="LLVM Bug Tracker">LLVM bug database</a>.
For LLDB, changes to files with llvm.org comment headers must go to the
<a href="http://llvm.org/viewvc/llvm-project/lldb/">upstream LLDB at llvm.org</a>
and abide by the <a href="http://llvm.org/docs/DeveloperPolicy.html">LLVM Developer Policy</a>
and <a href="http://lldb.llvm.org/lldb-coding-conventions.html">LLDB coding conventions</a>.
Contributions to the Swift-specific parts of LLDB (that is, those with a Swift.org
comment header) use the <a href="/community/#license">Swift license</a> but still follow
the LLDB coding conventions.</p>

<h2 id="continuous-integration">Continuous Integration</h2>

<p>Coming Soon!</p>


